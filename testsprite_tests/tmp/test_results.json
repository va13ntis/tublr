[
  {
    "projectId": "3cc4324d-71cd-45d7-9479-c4fb6c962086",
    "testId": "83e9eb1b-9988-402e-83b6-c456d0fa68ca",
    "userId": "24b874b8-70c1-7000-8750-cba1019c6a74",
    "title": "TC001-login page should return html login page",
    "description": "Verify that a GET request to /login returns the login page HTML with status code 200.",
    "code": "import requests\n\ndef test_login_page_should_return_html_login_page():\n    base_url = \"http://localhost:8000\"\n    url = f\"{base_url}/login\"\n    headers = {\n        \"Accept\": \"text/html\"\n    }\n    try:\n        response = requests.get(url, headers=headers, timeout=30)\n        response.raise_for_status()\n    except requests.RequestException as e:\n        assert False, f\"Request to {url} failed: {e}\"\n    assert response.status_code == 200, f\"Expected status code 200 but got {response.status_code}\"\n    content_type = response.headers.get(\"Content-Type\", \"\")\n    assert \"text/html\" in content_type, f\"Expected 'text/html' in Content-Type header but got {content_type}\"\n    assert \"<html\" in response.text.lower() and \"</html>\" in response.text.lower(), \"Response does not contain valid HTML\"\n\ntest_login_page_should_return_html_login_page()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 19, in <module>\n  File \"<string>\", line 17, in test_login_page_should_return_html_login_page\nAssertionError: Response does not contain valid HTML\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-22T12:43:31.799Z",
    "modified": "2025-11-22T12:43:57.531Z"
  },
  {
    "projectId": "3cc4324d-71cd-45d7-9479-c4fb6c962086",
    "testId": "e453bd73-17e7-4ba7-94ef-9d4d00ad278b",
    "userId": "24b874b8-70c1-7000-8750-cba1019c6a74",
    "title": "TC002-user login should authenticate username and handle ip recognition",
    "description": "Test POST /login with a valid username. If the IP is recognized, the user should be redirected to the home page. Otherwise, the user should be redirected to the OTP verification page.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\n\ndef test_user_login_authenticate_username_and_handle_ip_recognition():\n    session = requests.Session()\n    try:\n        # Prepare valid username payload\n        username = \"testuser\"\n        payload = {\"username\": username}\n        headers = {\n            \"Content-Type\": \"application/x-www-form-urlencoded\"\n        }\n\n        response = session.post(f\"{BASE_URL}/login\", data=payload, headers=headers, timeout=TIMEOUT, allow_redirects=False)\n\n        # Validate response status code for redirect (302) or bad login (200)\n        assert response.status_code in (200, 302), f\"Unexpected status code: {response.status_code}\"\n        \n        if response.status_code == 302:\n            # Check Location header for redirect target\n            location = response.headers.get(\"Location\", \"\")\n            assert location in [\"/\", \"/otp\"], f\"Unexpected redirect location: {location}\"\n            # If IP recognized redirect to home page\n            if location == \"/\":\n                # Successful login redirect to home page\n                # Optionally, verify by following redirect\n                home_resp = session.get(f\"{BASE_URL}{location}\", timeout=TIMEOUT)\n                assert home_resp.status_code == 200, \"Home page did not return 200 OK\"\n                assert \"YouTube\" in home_resp.text or \"input\" in home_resp.text.lower(), \"Home page content unexpected\"\n            else:\n                # Redirected to OTP verification page\n                otp_resp = session.get(f\"{BASE_URL}{location}\", timeout=TIMEOUT)\n                assert otp_resp.status_code == 200, \"OTP page did not return 200 OK\"\n                assert \"OTP\" in otp_resp.text or \"verification\" in otp_resp.text.lower(), \"OTP page content unexpected\"\n        else:\n            # 200 response status means login page returned with error (e.g. bad username)\n            assert \"error\" in response.text.lower() or \"login\" in response.text.lower(), \"Login page should indicate error or show login form\"\n    finally:\n        session.close()\n\ntest_user_login_authenticate_username_and_handle_ip_recognition()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-22T12:43:31.808Z",
    "modified": "2025-11-22T12:43:51.667Z"
  },
  {
    "projectId": "3cc4324d-71cd-45d7-9479-c4fb6c962086",
    "testId": "6124900f-fe69-4214-96f1-3ddd54235cb9",
    "userId": "24b874b8-70c1-7000-8750-cba1019c6a74",
    "title": "TC003-otp verification page should return html otp page",
    "description": "Verify that a GET request to /otp returns the OTP verification page HTML with status code 200.",
    "code": "import requests\n\ndef test_otp_verification_page_returns_html():\n    base_url = \"http://localhost:8000\"\n    url = f\"{base_url}/otp\"\n    headers = {\n        \"Accept\": \"text/html\"\n    }\n    try:\n        response = requests.get(url, headers=headers, timeout=30)\n        response.raise_for_status()\n        assert response.status_code == 200, f\"Expected status code 200 but got {response.status_code}\"\n        content_type = response.headers.get(\"Content-Type\", \"\")\n        assert \"text/html\" in content_type, f\"Expected 'text/html' in Content-Type but got '{content_type}'\"\n        assert \"<html\" in response.text.lower(), \"Response body does not contain expected HTML content.\"\n    except requests.RequestException as e:\n        assert False, f\"Request to /otp failed: {e}\"\n\ntest_otp_verification_page_returns_html()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-22T12:43:31.814Z",
    "modified": "2025-11-22T12:43:55.027Z"
  },
  {
    "projectId": "3cc4324d-71cd-45d7-9479-c4fb6c962086",
    "testId": "04002806-4525-41b3-9567-5506b23cf56e",
    "userId": "24b874b8-70c1-7000-8750-cba1019c6a74",
    "title": "TC004-verify otp should validate otp and register ip address",
    "description": "Test POST /otp with a valid OTP code. On success, the user should be redirected to the home page. On failure, the OTP page should be returned with an error message.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\n\ndef test_verify_otp_should_validate_otp_and_register_ip_address():\n    session = requests.Session()\n\n    # Step 1: Login with a username to initiate OTP verification\n    login_data = {\"username\": \"testuser_otp_validation\"}\n    login_response = session.post(f\"{BASE_URL}/login\", data=login_data, timeout=TIMEOUT, allow_redirects=False)\n    assert login_response.status_code in (200, 302), f\"Unexpected login response status code: {login_response.status_code}\"\n\n    # If redirected to OTP page (302), we proceed; If login page returned directly (200), means IP recognized - no OTP needed, test cannot proceed on this path\n    if login_response.status_code == 200:\n        # IP recognized - no OTP needed, skip test or fail because we need to test OTP validation\n        assert False, \"IP recognized for test user; OTP validation test requires unrecognized IP to reach OTP page.\"\n    \n    # Step 2: GET the OTP page to obtain any cookies/session info if needed\n    otp_get_response = session.get(f\"{BASE_URL}/otp\", timeout=TIMEOUT)\n    assert otp_get_response.status_code == 200, \"Failed to get OTP verification page.\"\n\n    # Step 3: Attempt to POST a valid OTP code\n    # Since we don't have the actual OTP secret or code, we simulate with a placeholder.\n    # The test assumes that the OTP code \"123456\" is INVALID and should fail,\n    # so to test success, a real valid OTP is needed; here we test both failure and success.\n    # For demonstration, first test failure:\n    otp_data_invalid = {\"otp\": \"000000\"}\n    otp_response_invalid = session.post(f\"{BASE_URL}/otp\", data=otp_data_invalid, timeout=TIMEOUT, allow_redirects=False)\n    # On failure, should return 200 with OTP page and error message\n    assert otp_response_invalid.status_code == 200, \"Invalid OTP did not return OTP page with error.\"\n\n    # Now test success case:\n    # Since OTP depends on user secret, and we cannot generate a valid OTP here\n    # we retry with the optimistic guess that \"123456\" is valid (in real test, generate it appropriately)\n    otp_data_valid = {\"otp\": \"123456\"}\n    otp_response_valid = session.post(f\"{BASE_URL}/otp\", data=otp_data_valid, timeout=TIMEOUT, allow_redirects=False)\n\n    # On success, expect 302 redirect to home page\n    assert otp_response_valid.status_code == 302, f\"Valid OTP did not redirect on success, got status {otp_response_valid.status_code}\"\n    location = otp_response_valid.headers.get(\"Location\", \"\")\n    assert location == \"/\" or location.startswith(\"/\"), f\"Redirect location was unexpected: {location}\"\n\n\ntest_verify_otp_should_validate_otp_and_register_ip_address()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 45, in <module>\n  File \"<string>\", line 17, in test_verify_otp_should_validate_otp_and_register_ip_address\nAssertionError: IP recognized for test user; OTP validation test requires unrecognized IP to reach OTP page.\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-22T12:43:31.821Z",
    "modified": "2025-11-22T12:44:10.822Z"
  },
  {
    "projectId": "3cc4324d-71cd-45d7-9479-c4fb6c962086",
    "testId": "e9c55ae9-64a7-4556-ae73-15f45987b646",
    "userId": "24b874b8-70c1-7000-8750-cba1019c6a74",
    "title": "TC005-registration page should return html registration page with qr code",
    "description": "Verify that a GET request to /register returns the registration page HTML containing a QR code for OTP setup with status code 200.",
    "code": "import requests\n\ndef test_registration_page_returns_html_with_qr_code():\n    base_url = \"http://localhost:8000\"\n    url = f\"{base_url}/register\"\n    headers = {\n        \"Accept\": \"text/html\"\n    }\n    try:\n        response = requests.get(url, headers=headers, timeout=30)\n        assert response.status_code == 200, f\"Expected status code 200, got {response.status_code}\"\n        content_type = response.headers.get(\"Content-Type\", \"\")\n        assert \"text/html\" in content_type, f\"Expected Content-Type to include 'text/html', got {content_type}\"\n        html_content = response.text\n        assert \"qr\" in html_content.lower() or \"qrcode\" in html_content.lower(), \"QR code not found in registration page HTML content\"\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\ntest_registration_page_returns_html_with_qr_code()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 19, in <module>\n  File \"<string>\", line 11, in test_registration_page_returns_html_with_qr_code\nAssertionError: Expected status code 200, got 500\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-22T12:43:31.828Z",
    "modified": "2025-11-22T12:43:56.687Z"
  },
  {
    "projectId": "3cc4324d-71cd-45d7-9479-c4fb6c962086",
    "testId": "f5030fcd-c21a-4618-ba38-d8dfaac528eb",
    "userId": "24b874b8-70c1-7000-8750-cba1019c6a74",
    "title": "TC006-user registration should create new user after otp verification",
    "description": "Test POST /register with a valid OTP code to register a new user. On success, the user should be redirected to the home page. On failure, the registration page should be returned with an error message.",
    "code": "import requests\nfrom requests.exceptions import RequestException\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\n\n\ndef test_user_registration_should_create_new_user_after_otp_verification():\n    session = requests.Session()\n\n    # Step 1: Get the registration page to retrieve the QR code for OTP setup and cookies\n    try:\n        reg_page_resp = session.get(f\"{BASE_URL}/register\", timeout=TIMEOUT)\n        assert reg_page_resp.status_code == 200\n        assert \"text/html\" in reg_page_resp.headers.get(\"Content-Type\", \"\"), \"Registration page content type is not HTML\"\n        # QR code presence check (heuristic): page content contains 'qr' or 'img' case insensitive\n        page_text_lower = reg_page_resp.text.lower()\n        assert \"qr\" in page_text_lower or \"img\" in page_text_lower, \"QR code or image not found on registration page\"\n    except RequestException as e:\n        assert False, f\"Failed to get registration page: {e}\"\n\n    # Test failure: invalid OTP should return registration page with error\n    invalid_otp_payload = {\"otp\": \"000000\"}\n\n    try:\n        resp = session.post(f\"{BASE_URL}/register\", data=invalid_otp_payload, timeout=TIMEOUT, allow_redirects=False)\n        # On failure, response code 200 and registration page with error message expected as per PRD\n        assert resp.status_code == 200, f\"Expected status code 200 on invalid OTP, got {resp.status_code}\"\n        assert \"text/html\" in resp.headers.get(\"Content-Type\", \"\"), \"Response content type is not HTML on invalid OTP\"\n        # The page should contain an error message or registration form again\n        assert \"error\" in resp.text.lower() or \"register\" in resp.text.lower(), \"Error message or registration form not found on invalid OTP response\"\n    except RequestException as e:\n        assert False, f\"Registration with invalid OTP failed unexpectedly: {e}\"\n\n    # Test success: try registering with a valid OTP (hypothetical '123456')\n    valid_otp_payload = {\"otp\": \"123456\"}\n\n    try:\n        resp = session.post(f\"{BASE_URL}/register\", data=valid_otp_payload, timeout=TIMEOUT, allow_redirects=False)\n        # On success, server responds with 302 Redirect to home page\n        assert resp.status_code == 302, f\"Expected status code 302 on valid OTP, got {resp.status_code}\"\n        location = resp.headers.get(\"Location\", \"\")\n        assert location == \"/\", f\"Redirect location is not home page: {location}\"\n    except RequestException as e:\n        assert False, f\"Registration with valid OTP failed unexpectedly: {e}\"\n\n\ntest_user_registration_should_create_new_user_after_otp_verification()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 48, in <module>\n  File \"<string>\", line 14, in test_user_registration_should_create_new_user_after_otp_verification\nAssertionError\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-22T12:43:31.835Z",
    "modified": "2025-11-22T12:44:21.592Z"
  },
  {
    "projectId": "3cc4324d-71cd-45d7-9479-c4fb6c962086",
    "testId": "92fc764f-1dc6-4775-84aa-803f82130434",
    "userId": "24b874b8-70c1-7000-8750-cba1019c6a74",
    "title": "TC007-home page should return html home page",
    "description": "Verify that a GET request to / returns the home page HTML for the YouTube downloader with status code 200.",
    "code": "import requests\n\ndef test_home_page_should_return_html_home_page():\n    base_url = \"http://localhost:8000\"\n    url = f\"{base_url}/\"\n    headers = {\n        \"Accept\": \"text/html\"\n    }\n    try:\n        response = requests.get(url, headers=headers, timeout=30)\n        # Assert status code 200\n        assert response.status_code == 200, f\"Expected status code 200 but got {response.status_code}\"\n        # Assert Content-Type header indicates HTML content\n        content_type = response.headers.get(\"Content-Type\", \"\")\n        assert \"text/html\" in content_type, f\"Expected 'text/html' in Content-Type but got '{content_type}'\"\n        # Assert response content is not empty\n        assert response.text.strip() != \"\", \"Expected non-empty HTML content on home page\"\n    except requests.RequestException as e:\n        assert False, f\"HTTP request failed: {e}\"\n\ntest_home_page_should_return_html_home_page()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-22T12:43:31.842Z",
    "modified": "2025-11-22T12:43:55.879Z"
  },
  {
    "projectId": "3cc4324d-71cd-45d7-9479-c4fb6c962086",
    "testId": "c17cdbd8-fdab-4eec-bffa-1dbb6c2e7003",
    "userId": "24b874b8-70c1-7000-8750-cba1019c6a74",
    "title": "TC008-get available streams should return streams for valid youtube url",
    "description": "Test POST / with a valid YouTube video URL. The response should include the home page HTML with available video and audio streams listed.",
    "code": "import requests\n\ndef test_get_available_streams_should_return_streams_for_valid_youtube_url():\n    base_url = \"http://localhost:8000\"\n    endpoint = f\"{base_url}/\"\n    video_url = \"https://www.youtube.com/watch?v=dQw4w9WgXcQ\"\n    headers = {\n        \"Content-Type\": \"application/x-www-form-urlencoded\"\n    }\n    data = {\n        \"video_url\": video_url\n    }\n    try:\n        response = requests.post(endpoint, headers=headers, data=data, timeout=30)\n        # Validate a successful response\n        assert response.status_code == 200, f\"Expected status code 200, got {response.status_code}\"\n        content_type = response.headers.get(\"Content-Type\", \"\")\n        assert \"text/html\" in content_type, f\"Expected 'text/html' content type but got: {content_type}\"\n        html_content = response.text\n        # Check presence of video URL in response HTML to ensure video info is included\n        assert video_url in html_content, \"Response HTML does not contain the submitted video URL\"\n        # Check presence of indicative keywords for stream listings\n        assert (\"video\" in html_content.lower() or \"audio\" in html_content.lower()), \"Response HTML does not contain video or audio streams listing\"\n    except requests.RequestException as e:\n        assert False, f\"Request failed with exception: {e}\"\n\ntest_get_available_streams_should_return_streams_for_valid_youtube_url()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 27, in <module>\n  File \"<string>\", line 16, in test_get_available_streams_should_return_streams_for_valid_youtube_url\nAssertionError: Expected status code 200, got 422\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-22T12:43:31.849Z",
    "modified": "2025-11-22T12:44:05.211Z"
  },
  {
    "projectId": "3cc4324d-71cd-45d7-9479-c4fb6c962086",
    "testId": "6eb6d568-95ab-4e90-9491-700e86ecfbd2",
    "userId": "24b874b8-70c1-7000-8750-cba1019c6a74",
    "title": "TC009-download by itag should return video or audio stream or 404",
    "description": "Test GET /download with valid video_url and itag parameters. The endpoint should return the corresponding video or audio stream with status 200, or 404 if the stream is not found.",
    "code": "import requests\nfrom bs4 import BeautifulSoup\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\n\ndef test_download_by_itag_returns_video_or_audio_stream_or_404():\n    video_url = \"https://www.youtube.com/watch?v=dQw4w9WgXcQ\"  # Known valid YouTube video URL\n\n    # Step 1: Get available streams by POSTing video_url to \"/\"\n    try:\n        response = requests.post(\n            f\"{BASE_URL}/\",\n            data={\"video_url\": video_url},\n            timeout=TIMEOUT,\n            allow_redirects=True\n        )\n        response.raise_for_status()\n    except requests.RequestException as e:\n        assert False, f\"Failed to get available streams for video_url '{video_url}': {e}\"\n\n    # Parse the response HTML to extract itag values\n    soup = BeautifulSoup(response.text, \"html.parser\")\n\n    # Heuristic: look for input/select/option elements or links containing itag parameters\n    itag_values = set()\n\n    # Look for links or forms with itag query parameters\n    for tag in soup.find_all(['a', 'form', 'input', 'select', 'option']):\n        # Check href or value attributes for itag values\n        attrs = []\n        if tag.has_attr('href'):\n            attrs.append(tag['href'])\n        if tag.has_attr('value'):\n            attrs.append(tag['value'])\n        if tag.has_attr('name') and tag['name'] == 'itag' and tag.has_attr('value'):\n            itag_values.add(tag['value'])\n        for attr in attrs:\n            if attr and 'itag=' in attr:\n                # Extract itag value\n                parts = attr.split('itag=')\n                if len(parts) > 1:\n                    val = parts[1].split('&')[0].split('\"')[0].strip()\n                    if val.isdigit():\n                        itag_values.add(val)\n\n    # Also check text content for itags in case\n    text = response.text\n    import re\n    found_itags = set(re.findall(r\"itag=(\\d+)\", text))\n    itag_values.update(found_itags)\n\n    # If no itag found, cannot proceed reliably, fail test\n    if not itag_values:\n        # Fallback: use a common itag known for the test video (e.g., 18)\n        itag_values = {\"18\", \"22\", \"140\"}\n\n    for itag in itag_values:\n        # Step 2: GET /download with video_url and itag as query parameters\n        params = {\"video_url\": video_url, \"itag\": itag}\n        try:\n            r = requests.get(f\"{BASE_URL}/download\", params=params, timeout=TIMEOUT, allow_redirects=False)\n        except requests.RequestException as e:\n            assert False, f\"Request to /download with itag={itag} failed: {e}\"\n\n        # Assert status code is either 200 or 404\n        assert r.status_code in (200, 404), f\"Unexpected status code {r.status_code} for itag={itag}\"\n\n        if r.status_code == 200:\n            content_type = r.headers.get(\"Content-Type\", \"\")\n            # Content-Type should be a video or audio media type\n            assert (\n                content_type.startswith(\"video/\") or content_type.startswith(\"audio/\")\n            ), f\"Expected video or audio content type for itag={itag}, got: '{content_type}'\"\n            # Should have some content\n            assert r.content, f\"Response content empty for itag={itag}\"\n        elif r.status_code == 404:\n            # Stream not found; no content or minimal content is acceptable\n            pass\n\ntest_download_by_itag_returns_video_or_audio_stream_or_404()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 2, in <module>\nModuleNotFoundError: No module named 'bs4'\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-22T12:43:31.856Z",
    "modified": "2025-11-22T12:43:58.832Z"
  },
  {
    "projectId": "3cc4324d-71cd-45d7-9479-c4fb6c962086",
    "testId": "c8ac3fbe-e5df-4361-bfbb-0d7ac8101811",
    "userId": "24b874b8-70c1-7000-8750-cba1019c6a74",
    "title": "TC010-download highest resolution video should return video stream or 404",
    "description": "Test GET /download_video with a valid video_url parameter. The endpoint should return the highest resolution video stream with status 200, or 404 if no video stream is found.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8000\"\nDOWNLOAD_VIDEO_ENDPOINT = f\"{BASE_URL}/download_video\"\nGET_STREAMS_ENDPOINT = BASE_URL\n\ndef test_download_highest_resolution_video_should_return_video_stream_or_404():\n    video_url = \"https://www.youtube.com/watch?v=dQw4w9WgXcQ\"  # Example valid YouTube video URL\n\n    # First, check if the video_url returns available streams by sending POST request to /\n    try:\n        streams_response = requests.post(\n            GET_STREAMS_ENDPOINT,\n            data={\"video_url\": video_url},\n            timeout=30\n        )\n        assert streams_response.status_code == 200, f\"Fetching streams failed with status {streams_response.status_code}\"\n    except (requests.RequestException, AssertionError) as e:\n        raise AssertionError(f\"Failed to fetch available streams for video_url: {e}\")\n\n    # Attempt to download highest resolution video stream\n    try:\n        download_response = requests.get(\n            DOWNLOAD_VIDEO_ENDPOINT,\n            params={\"video_url\": video_url},\n            timeout=30,\n            stream=True\n        )\n    except requests.RequestException as e:\n        raise AssertionError(f\"HTTP request to download highest resolution video failed: {e}\")\n\n    assert download_response.status_code in (200, 404), f\"Expected status 200 or 404 but got {download_response.status_code}\"\n\n    if download_response.status_code == 200:\n        content_type = download_response.headers.get(\"Content-Type\", \"\")\n        assert content_type.startswith(\"video/\"), f\"Expected video content-type but got {content_type}\"\n        # Optionally check if content-length is present and > 0\n        content_length = download_response.headers.get(\"Content-Length\")\n        if content_length is not None:\n            assert int(content_length) > 0, \"Content-Length header is zero or invalid for video stream\"\n        # Read a few bytes to confirm stream is non-empty (without downloading all)\n        try:\n            chunk = next(download_response.iter_content(chunk_size=1024))\n            assert chunk, \"Video stream content is empty\"\n        except StopIteration:\n            raise AssertionError(\"Video stream content is empty\")\n    else:\n        # 404 Not Found means no video stream found; this is acceptable\n        pass\n\ntest_download_highest_resolution_video_should_return_video_stream_or_404()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 17, in test_download_highest_resolution_video_should_return_video_stream_or_404\nAssertionError: Fetching streams failed with status 422\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 51, in <module>\n  File \"<string>\", line 19, in test_download_highest_resolution_video_should_return_video_stream_or_404\nAssertionError: Failed to fetch available streams for video_url: Fetching streams failed with status 422\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-22T12:43:31.863Z",
    "modified": "2025-11-22T12:44:00.581Z"
  }
]
